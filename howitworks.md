# git-reword (how it works)

**Это небольшой рассказ о том, как работает git-reword.**

**Предполагается полное прочтение README.md перед прочтением этого файла.**

Далее команда "git rebase --interactive" сокращённо называется gri.

Кстати, заметим, что изначально предполагалось разработать замену именно для команды gri, которая сама
обладает некоторыми ограничениями, поэтому аналогичные ограничения можно было ввести и в собственной программе. gri неудобно работает с непрямыми участками:
например, merge-commit'ы уничтожает. Поэтому все версии git-reword не выполняют общую задачу переименовывания коммитов идеально, как и gri. 
Насколько я понимаю, эту задачу вообще невозможно хорошо решать во всех случаях из-за ограничений самого git. Но некоторые сложные случаи всё же можно учесть,
некоторые даже учтены в некоторых версиях, но требуют дополнительного тестирования и доработки, поэтому незадокументированы.

## История: почему несколько версий

Для начала нужно понять, как хранится информация о коммитах в git. Для этого хорошо подходит следующий материал: 
[EN](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects), 
[RU](https://git-scm.com/book/ru/v2/Git-изнутри-Объекты-Git).

В результате узнаём, что многое в git хранится в виде объектов (object) в объектной базе данных (odb). Так же узнаём некоторые 
команды git для продвинутого использования (например, "git cat-file <rev> -t", "git cat-file <rev> -p") (они позволяют работать с объектами в odb).
Тогда становится очень простой задачей написать скрипт, который, используя эти команды, выполняет требуемую задачу. Так появился *py_git*.

Необходимо было научится сравнивать его производительность с gri. Кроме того у этой команды очень неудобный 
для комфортного использования способ ввода данных (через текстовый редактор). Поэтому был создан скрипт, для автоматического выполнения 
"git rebase --interactive" в нужном формате. Так появился *py_git-rebase*.

Наконец, можно убедиться, что *py_git* не так уж эффективен, как мог бы быть. Кроме того существовали изначальные рекомендации решить задачу используя 
libgit2 или JGit. Так появился *cpp_libgit2*.

## Теория

Коммит имеет список родителей (да, родителей может быть произвольное количество). Тогда коммиты образуют некоторый ориентированный ациклический граф (DAG) 
(изначально предполагается, что граф ациклический).

Многое в git хранится в виде объектов (object) в объектной базе данных (odb).

Каждый отдельный объект в odb это что-то вроде файла. Объект имеет тип и содержимое.

Коммит -- один из типов объектов, которые хранятся в odb. Его содержимое хранит саму информацию коммита: список родительских коммитов, 
информацию об авторе, информацию о коммиттере, сообщение коммита и некоторую другую информацию.

Каждый объект обладает уникальным идентификатором объекта (oid), которым, по сути, является хеш-значение объекта, точнее хеш-значение содержимого объекта.

Объекты так же можно идентифицировать не через oid, а некоторыми другими способами. Любая строка, которая идентифицирует объект каким-либо образом, 
называется ревизией (revision/rev). Например можно идентифицировать второй объект до HEAD с помощью строки (ревизии) "HEAD~2".

Теперь пусть мы хотим поменять сообщение коммита. Тогда изменится содержимое коммита. Тогда изменится хеш-значение коммита, то есть его oid.  
В итоге, если где-то в git-структуре были ссылки на этот коммит, то они сломаются, потому что oid изменился. Чтобы всё было безопасно, 
мы можем оставить старый коммит (а не удалять его). Но теперь мы создадим новый, он будет почти полной копией старого, но у него будет новое сообщение. 
Теперь мы можем использовать его вместо старого. Но это ещё не всё. Если у этого коммита были потомки, то есть коммиты, у которых изменённый коммит 
присутствовал в писке родителей, то у нашей копии нет этих потомков. Тут, видимо, проблема в том, что git строит односвязную структуру коммитов, 
то есть связи идут только от потомков к родителям. Тогда нам понадобится создать копии потомков, а потом копии потомков потомков и т.д. 
Таким образом, потребуется обновить всю структуру коммитов-потомков. Но опять же, у коммитов нет связей от предков к потомкам, поэтому данную задачу 
не очень понятно, как выполнять. Тогда мы вспоминаем, как с этой проблемой боролась gri. Да она никак с проблемой не боролась, а просто распрямлял сложный 
участок (TODO). Но нам так делать нельзя, потому что мы не хотим ни как менять/портить структуру коммитов, а только хотим изменять сообщения. В результате 
получается естественное ограничение на то, какие коммиты и участки программа должна уметь обрабатывать, то есть будет работать только с простыми участками.

## Алгоритм

В результате получаем формальный алгоритм (примерно одинаковый во всех версиях):

1. Разрешаем все введённые ревизии, то есть находим соответствующие oid'ы 
(например введено "HEAD~5", но мы хотим знать oid, то есть например b53169a8deb5650aac81cec14ef96f72e0333152). Сохраняем их куда-то (в словарь).

2. Получаем последовательность коммитов, где каждый следующий является потомком предыдущих, при этом все подлежащие изменению коммиты лежат в этом списке. 
ПО сути, этот список почти является тем, что выводит "git log A..B", если смотреть снизу вверх (здесь A и B -- какие-то коммиты). 
Пусть этот список ограничен с одной стороны самым родительским коммитом среди тех, которые мы хотим изменить, назовём это коммит S. 
Пусть с другой стороны список ограничен вершиной ветки.

3. Идём по этому списку в заданном направлении. Пусть текущий коммит X. Создаём коммит Y, который является копией X. Будет у Y всего лишь несколько отличий от X: 
в сообщении (или нет, если мы не собирались его менять), в списке родительских коммитов. Каждый идентификатор родительского коммита в списке родительских 
коммитов мы заменяем на идентификатор копии соответствующей этому родительскому коммиту.

4. Пусть мы закончили обрабатывать  этот список. Тогда последним элементом был X, а его копией был Y. Получается, что X -- вершина ветки, а Y -- копия вершины 
ветки. Устанавливаем вершину ветки (и HEAD) в Y.
